"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const utils_1 = __importDefault(require("./utils"));
assert_1.default(typeof BigInt !== 'undefined', 'Apparently you are using old version of node. Please upgrade to node 10.4.x or above.');
var DataType;
(function (DataType) {
    DataType[DataType["Extended"] = 0] = "Extended";
    DataType[DataType["Pointer"] = 1] = "Pointer";
    DataType[DataType["Utf8String"] = 2] = "Utf8String";
    DataType[DataType["Double"] = 3] = "Double";
    DataType[DataType["Bytes"] = 4] = "Bytes";
    DataType[DataType["Uint16"] = 5] = "Uint16";
    DataType[DataType["Uint32"] = 6] = "Uint32";
    DataType[DataType["Map"] = 7] = "Map";
    DataType[DataType["Int32"] = 8] = "Int32";
    DataType[DataType["Uint64"] = 9] = "Uint64";
    DataType[DataType["Uint128"] = 10] = "Uint128";
    DataType[DataType["Array"] = 11] = "Array";
    DataType[DataType["Container"] = 12] = "Container";
    DataType[DataType["EndMarker"] = 13] = "EndMarker";
    DataType[DataType["Boolean"] = 14] = "Boolean";
    DataType[DataType["Float"] = 15] = "Float";
})(DataType || (DataType = {}));
const pointerValueOffset = [0, 2048, 526336, 0];
const noCache = {
    get: () => undefined,
    set: () => undefined,
};
const cursor = (value, offset) => ({ value, offset });
class Decoder {
    constructor(db, baseOffset = 0, cache = noCache) {
        this.telemetry = {};
        assert_1.default((this.db = db), 'Database buffer is required');
        this.baseOffset = baseOffset;
        this.cache = cache;
    }
    decode(offset) {
        let tmp;
        const ctrlByte = this.db[offset++];
        let type = ctrlByte >> 5;
        if (type === DataType.Pointer) {
            tmp = this.decodePointer(ctrlByte, offset);
            return cursor(this.decodeFast(tmp.value).value, tmp.offset);
        }
        if (type === DataType.Extended) {
            tmp = this.db[offset] + 7;
            if (tmp < 8) {
                throw new Error('Invalid Extended Type at offset ' + offset + ' val ' + tmp);
            }
            type = tmp;
            offset++;
        }
        const size = this.sizeFromCtrlByte(ctrlByte, offset);
        return this.decodeByType(type, size.offset, size.value);
    }
    decodeFast(offset) {
        const cached = this.cache.get(offset);
        if (cached) {
            return cached;
        }
        const result = this.decode(offset);
        this.cache.set(offset, result);
        return result;
    }
    decodeByType(type, offset, size) {
        const newOffset = offset + size;
        switch (type) {
            case DataType.Utf8String:
                return cursor(this.decodeString(offset, size), newOffset);
            case DataType.Map:
                return this.decodeMap(size, offset);
            case DataType.Uint32:
                return cursor(this.decodeUint(offset, size), newOffset);
            case DataType.Double:
                return cursor(this.decodeDouble(offset), newOffset);
            case DataType.Array:
                return this.decodeArray(size, offset);
            case DataType.Boolean:
                return cursor(this.decodeBoolean(size), offset);
            case DataType.Float:
                return cursor(this.decodeFloat(offset), newOffset);
            case DataType.Bytes:
                return cursor(this.decodeBytes(offset, size), newOffset);
            case DataType.Uint16:
                return cursor(this.decodeUint(offset, size), newOffset);
            case DataType.Int32:
                return cursor(this.decodeInt32(offset, size), newOffset);
            case DataType.Uint64:
                return cursor(this.decodeUint(offset, size), newOffset);
            case DataType.Uint128:
                return cursor(this.decodeUint(offset, size), newOffset);
        }
        throw new Error('Unknown type ' + type + ' at offset ' + offset);
    }
    sizeFromCtrlByte(ctrlByte, offset) {
        const size = ctrlByte & 0x1f;
        if (size < 29) {
            return cursor(size, offset);
        }
        if (size === 29) {
            return cursor(29 + this.db[offset], offset + 1);
        }
        if (size === 30) {
            return cursor(285 + this.db.readUInt16BE(offset, false), offset + 2);
        }
        return cursor(65821 +
            utils_1.default.concat3(this.db[offset], this.db[offset + 1], this.db[offset + 2]), offset + 3);
    }
    decodeBytes(offset, size) {
        return this.db.slice(offset, offset + size);
    }
    decodePointer(ctrlByte, offset) {
        const pointerSize = (ctrlByte >> 3) & 3;
        const pointer = this.baseOffset + pointerValueOffset[pointerSize];
        let packed = 0;
        if (pointerSize === 0) {
            packed = utils_1.default.concat2(ctrlByte & 7, this.db[offset]);
        }
        else if (pointerSize === 1) {
            packed = utils_1.default.concat3(ctrlByte & 7, this.db[offset], this.db[offset + 1]);
        }
        else if (pointerSize === 2) {
            packed = utils_1.default.concat4(ctrlByte & 7, this.db[offset], this.db[offset + 1], this.db[offset + 2]);
        }
        else {
            packed = this.db.readUInt32BE(offset, true);
        }
        offset += pointerSize + 1;
        return cursor(pointer + packed, offset);
    }
    decodeArray(size, offset) {
        let tmp;
        const array = [];
        for (let i = 0; i < size; i++) {
            tmp = this.decode(offset);
            offset = tmp.offset;
            array.push(tmp.value);
        }
        return cursor(array, offset);
    }
    decodeBoolean(size) {
        return size !== 0;
    }
    decodeDouble(offset) {
        return this.db.readDoubleBE(offset, true);
    }
    decodeFloat(offset) {
        return this.db.readFloatBE(offset, true);
    }
    decodeMap(size, offset) {
        let tmp;
        let key;
        const map = {};
        for (let i = 0; i < size; i++) {
            tmp = this.decode(offset);
            key = tmp.value;
            tmp = this.decode(tmp.offset);
            offset = tmp.offset;
            map[key] = tmp.value;
        }
        return cursor(map, offset);
    }
    decodeInt32(offset, size) {
        if (size === 0) {
            return 0;
        }
        return this.db.readInt32BE(offset, true);
    }
    decodeUint(offset, size) {
        switch (size) {
            case 0:
                return 0;
            case 1:
                return this.db[offset];
            case 2:
                return utils_1.default.concat2(this.db[offset + 0], this.db[offset + 1]);
            case 3:
                return utils_1.default.concat3(this.db[offset + 0], this.db[offset + 1], this.db[offset + 2]);
            case 4:
                return utils_1.default.concat4(this.db[offset + 0], this.db[offset + 1], this.db[offset + 2], this.db[offset + 3]);
            case 8:
                return this.decodeBigUint(offset, size);
            case 16:
                return this.decodeBigUint(offset, size);
        }
        return 0;
    }
    decodeString(offset, size) {
        return this.db.utf8Slice(offset, offset + size);
    }
    decodeBigUint(offset, size) {
        const buffer = Buffer.alloc(size);
        this.db.copy(buffer, 0, offset, offset + size);
        let integer = BigInt(0);
        const numberOfLongs = size / 4;
        for (let i = 0; i < numberOfLongs; i++) {
            integer =
                integer * BigInt(4294967296) +
                    BigInt(buffer.readUInt32BE(i << 2, true));
        }
        return integer.toString();
    }
}
exports.default = Decoder;
//# sourceMappingURL=decoder.js.map