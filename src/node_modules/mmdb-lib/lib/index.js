"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decoder_1 = __importDefault(require("./decoder"));
const ip_1 = __importDefault(require("./ip"));
const metadata_1 = require("./metadata");
const walker_1 = __importDefault(require("./reader/walker"));
const DATA_SECTION_SEPARATOR_SIZE = 16;
class Reader {
    constructor(db, opts = {}) {
        this.db = db;
        this.metadata = metadata_1.parseMetadata(this.db);
        this.decoder = new decoder_1.default(this.db, this.metadata.searchTreeSize + DATA_SECTION_SEPARATOR_SIZE, opts.cache);
        this.walker = walker_1.default(this.db, this.metadata.recordSize);
        this.ipv4StartNodeNumber = this.ipv4Start();
    }
    get(ipAddress) {
        const [data] = this.getWithPrefixLength(ipAddress);
        return data;
    }
    getWithPrefixLength(ipAddress) {
        const [pointer, prefixLength] = this.findAddressInTree(ipAddress);
        const data = pointer ? this.resolveDataPointer(pointer) : null;
        return [data, prefixLength];
    }
    findAddressInTree(ipAddress) {
        const rawAddress = ip_1.default.parse(ipAddress);
        const nodeCount = this.metadata.nodeCount;
        const bitLength = rawAddress.length * 8;
        let bit;
        let nodeNumber = 0;
        let offset;
        let depth = 0;
        if (rawAddress.length === 4) {
            nodeNumber = this.ipv4StartNodeNumber;
        }
        for (; depth < bitLength && nodeNumber < nodeCount; depth++) {
            bit = ip_1.default.bitAt(rawAddress, depth);
            offset = nodeNumber * this.metadata.nodeByteSize;
            nodeNumber = bit ? this.walker.right(offset) : this.walker.left(offset);
        }
        if (nodeNumber > nodeCount) {
            return [nodeNumber, depth];
        }
        return [null, depth];
    }
    resolveDataPointer(pointer) {
        const resolved = pointer - this.metadata.nodeCount + this.metadata.searchTreeSize;
        return this.decoder.decodeFast(resolved).value;
    }
    ipv4Start() {
        if (this.metadata.ipVersion === 4) {
            return 0;
        }
        const nodeCount = this.metadata.nodeCount;
        let pointer = 0;
        let i = 0;
        for (; i < 96 && pointer < nodeCount; i++) {
            const offset = pointer * this.metadata.nodeByteSize;
            pointer = this.walker.left(offset);
        }
        return pointer;
    }
}
exports.default = Reader;
__exportStar(require("./reader/response"), exports);
//# sourceMappingURL=index.js.map