{"version":3,"sources":["webpack://LigaturesAddon/webpack/universalModuleDefinition","webpack://LigaturesAddon/webpack/bootstrap","webpack://LigaturesAddon/./src/LigaturesAddon.ts","webpack://LigaturesAddon/./src/index.ts","webpack://LigaturesAddon/./src/font.ts","webpack://LigaturesAddon/external \"font-finder\"","webpack://LigaturesAddon/external \"font-ligatures\"","webpack://LigaturesAddon/./src/parse.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__3__","__WEBPACK_EXTERNAL_MODULE__4__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","terminal","enableLigatures","term","currentFontName","undefined","font","loadingState","loadError","registerCharacterJoiner","text","termFont","getOption","currentCallFontName","then","f","refresh","catch","e","findLigatureRanges","map","range","Error","fontsPromise","async","fontFamily","cacheSize","fontFinder","list","fonts","family","genericFontFamilies","includes","length","fontLigatures","loadFile","path","parseString","context","quoteChar","str","escaped","offset","input","char","test","parseUnicode","parseIdentifier","endsWith","unicodeToString","codePoint","String","fromCodePoint","parseInt","families","currentFamily","push"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,eAAgBA,QAAQ,mBAChC,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,cAAe,kBAAmBJ,GAChB,iBAAZC,QACdA,QAAwB,eAAID,EAAQG,QAAQ,eAAgBA,QAAQ,mBAEpEJ,EAAqB,eAAIC,EAAQD,EAAK,eAAgBA,EAAK,mBAR7D,CASGO,QAAQ,SAASC,EAAgCC,GACpD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUV,QAGnC,IAAIC,EAASO,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHZ,QAAS,IAUV,OANAa,EAAQH,GAAUI,KAAKb,EAAOD,QAASC,EAAQA,EAAOD,QAASS,GAG/DR,EAAOW,GAAI,EAGJX,EAAOD,QA0Df,OArDAS,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASjB,EAASkB,EAAMC,GAC3CV,EAAoBW,EAAEpB,EAASkB,IAClCG,OAAOC,eAAetB,EAASkB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASzB,GACX,oBAAX0B,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAetB,EAAS0B,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAetB,EAAS,aAAc,CAAE4B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASnC,GAChC,IAAIkB,EAASlB,GAAUA,EAAO8B,WAC7B,WAAwB,OAAO9B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAQ,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G;;;;oDC5ErD,aAOA,uBACE,eAEO,SAASC,GACd,EAAAC,gBAAgBD,GAGX,c;;;;oDCZT,aAoBA,2BAAgCE,GAC9B,IAAIC,OAAsCC,EACtCC,OAAyBD,EACzBE,EAAY,EACZC,OAA6BH,EAEjCF,EAAKM,wBAAyBC,IAE5B,MAAMC,EAAWR,EAAKS,UAAU,cAChC,GACED,IACkB,IAAjBJ,GAA0CH,IAAoBO,GAC/D,CACAL,OAAOD,EACPE,EAAe,EACfH,EAAkBO,EAClB,MAAME,EAAsBT,EAE5B,UAAKS,EA3BQ,KA4BVC,KAAKC,IAGAF,IAAwBV,EAAKS,UAAU,gBACzCL,EAAe,EACfD,EAAOS,EAGHA,GACFZ,EAAKa,QAAQ,EAAGb,EAAKS,UAAU,QAAU,MAI9CK,MAAMC,IAGDL,IAAwBV,EAAKS,UAAU,gBACzCL,EAAe,EACfD,OAAOD,EACPG,EAAYU,KAKpB,GAAIZ,GAAyB,IAAjBC,EAGV,OAAOD,EAAKa,mBAAmBT,GAAMU,IACnCC,GAAS,CAACA,EAAM,GAAIA,EAAM,KAG9B,GAAqB,IAAjBd,EACF,MAAMC,GAAa,IAAIc,MAAM,8BAG/B,MAAO,O;;;;oDC7EX,aACA,OAEA,OAEA,IAAIC,OAAyDlB,EAQ7D,UAAemB,eAAoBC,EAAoBC,GAChDH,IACHA,EAAeI,EAAWC,QAG5B,MAAMC,QAAcN,EACpB,IAAK,MAAMO,KAAU,UAAML,GAAa,CAItC,GAAIM,EAAoBC,SAASF,GAC/B,OAGF,GAAID,EAAM/B,eAAegC,IAAWD,EAAMC,GAAQG,OAAS,EACzD,aAAaC,EAAcC,SAASN,EAAMC,GAAQ,GAAGM,KAAM,CAAEV,gBASnE,MAAMK,EAAsB,CAC1B,QACA,aACA,UACA,UACA,YACA,YACA,QACA,OACA,a,cCnDFxE,EAAOD,QAAUM,G,cCAjBL,EAAOD,QAAUO,G;;;;GCgEjB,SAASwE,EAAYC,EAAwBC,GAC3C,IAAIC,EAAM,GACNC,GAAU,EACd,KAAOH,EAAQI,OAASJ,EAAQK,MAAMV,QAAQ,CAC5C,MAAMW,EAAON,EAAQK,MAAML,EAAQI,UACnC,GAAID,EACE,cAAcI,KAAKD,IAErBN,EAAQI,SACRF,GAAOM,EAAaR,IACF,OAATM,IAETJ,GAAOI,GAETH,GAAU,OAEV,OAAQG,GAEN,KAAKL,EACH,OAAOC,EAET,IAAK,KACHC,GAAU,EACV,MAEF,QACED,GAAOI,GAKf,MAAM,IAAItB,MAAM,uBAQlB,SAASyB,EAAgBT,GACvB,IAAIE,EAAM,GACNC,GAAU,EACd,KAAOH,EAAQI,OAASJ,EAAQK,MAAMV,QAAQ,CAC5C,MAAMW,EAAON,EAAQK,MAAML,EAAQI,UACnC,GAAID,EACE,cAAcI,KAAKD,IAErBN,EAAQI,SACRF,GAAOM,EAAaR,IAGpBE,GAAOI,EAETH,GAAU,OAEV,OAAQG,GAEN,IAAK,KACHH,GAAU,EACV,MAEF,IAAK,IACH,OAAOD,EACT,QACM,KAAKK,KAAKD,GAEPJ,EAAIQ,SAAS,OAChBR,GAAO,KAITA,GAAOI,GAMjB,OAAOJ,EAQT,SAASM,EAAaR,GACpB,IAAIE,EAAM,GACV,KAAOF,EAAQI,OAASJ,EAAQK,MAAMV,QAAQ,CAC5C,MAAMW,EAAON,EAAQK,MAAML,EAAQI,UACnC,GAAI,KAAKG,KAAKD,GAGZ,OAAOK,EAAgBT,GAEzB,GAAIA,EAAIP,QAAU,IAAM,cAAcY,KAAKD,GAIzC,OADAN,EAAQI,SACDO,EAAgBT,GAIzBA,GAAOI,EAGT,OAAOK,EAAgBT,GAQzB,SAASS,EAAgBC,GACvB,OAAOC,OAAOC,cAAcC,SAASH,EAAW,K,iDAlKlD,mBAA8BpB,GAC5B,GAAsB,iBAAXA,EACT,MAAM,IAAIR,MAAM,gCAGlB,MAAMgB,EAAyB,CAC7BK,MAAOb,EACPY,OAAQ,GAGJY,EAAW,GACjB,IAAIC,EAAgB,GAIpB,KAAOjB,EAAQI,OAASJ,EAAQK,MAAMV,QAAQ,CAC5C,MAAMW,EAAON,EAAQK,MAAML,EAAQI,UACnC,OAAQE,GAEN,IAAK,IACL,IAAK,IACHW,GAAiBlB,EAAYC,EAASM,GACtC,MAEF,IAAK,IACHU,EAASE,KAAKD,GACdA,EAAgB,GAChB,MACF,QAEO,KAAKV,KAAKD,KACbN,EAAQI,SACRa,GAAiBR,EAAgBT,GACjCgB,EAASE,KAAKD,GACdA,EAAgB,KAKxB,OAAOD","file":"xterm-addon-ligatures.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"font-finder\"), require(\"font-ligatures\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"font-finder\", \"font-ligatures\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"LigaturesAddon\"] = factory(require(\"font-finder\"), require(\"font-ligatures\"));\n\telse\n\t\troot[\"LigaturesAddon\"] = factory(root[\"font-finder\"], root[\"font-ligatures\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { enableLigatures } from '.';\n\nexport interface ITerminalAddon {\n  activate(terminal: Terminal): void;\n  dispose(): void;\n}\n\nexport class LigaturesAddon implements ITerminalAddon {\n  constructor() {}\n\n  public activate(terminal: Terminal): void {\n    enableLigatures(terminal);\n  }\n\n  public dispose(): void {}\n}\n\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { Font } from 'font-ligatures';\n\nimport load from './font';\n\nconst enum LoadingState {\n  UNLOADED,\n  LOADING,\n  LOADED,\n  FAILED\n}\n\n// Caches 100K characters worth of ligatures. In practice this works out to\n// about 650 KB worth of cache, when a moderate number of ligatures are present.\nconst CACHE_SIZE = 100000;\n\n/**\n * Enable ligature support for the provided Terminal instance. To function\n * properly, this must be called after `open()` is called on the therminal. If\n * the font currently in use supports ligatures, the terminal will automatically\n * start to render them.\n * @param term Terminal instance from xterm.js\n */\nexport function enableLigatures(term: Terminal): void {\n  let currentFontName: string | undefined = undefined;\n  let font: Font | undefined = undefined;\n  let loadingState: LoadingState = LoadingState.UNLOADED;\n  let loadError: any | undefined = undefined;\n\n  term.registerCharacterJoiner((text: string): [number, number][] => {\n    // If the font hasn't been loaded yet, load it and return an empty result\n    const termFont = term.getOption('fontFamily');\n    if (\n      termFont &&\n      (loadingState === LoadingState.UNLOADED || currentFontName !== termFont)\n    ) {\n      font = undefined;\n      loadingState = LoadingState.LOADING;\n      currentFontName = termFont;\n      const currentCallFontName = currentFontName;\n\n      load(currentCallFontName, CACHE_SIZE)\n        .then(f => {\n          // Another request may have come in while we were waiting, so make\n          // sure our font is still vaild.\n          if (currentCallFontName === term.getOption('fontFamily')) {\n            loadingState = LoadingState.LOADED;\n            font = f;\n\n            // Only refresh things if we actually found a font\n            if (f) {\n              term.refresh(0, term.getOption('rows') - 1);\n            }\n          }\n        })\n        .catch(e => {\n          // Another request may have come in while we were waiting, so make\n          // sure our font is still vaild.\n          if (currentCallFontName === term.getOption('fontFamily')) {\n            loadingState = LoadingState.FAILED;\n            font = undefined;\n            loadError = e;\n          }\n        });\n    }\n\n    if (font && loadingState === LoadingState.LOADED) {\n      // We clone the entries to avoid the internal cache of the ligature finder\n      // getting messed up.\n      return font.findLigatureRanges(text).map<[number, number]>(\n        range => [range[0], range[1]]\n      );\n    }\n    if (loadingState === LoadingState.FAILED) {\n      throw loadError || new Error('Failure while loading font');\n    }\n\n    return [];\n  });\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport * as fontFinder from 'font-finder';\nimport * as fontLigatures from 'font-ligatures';\n\nimport parse from './parse';\n\nlet fontsPromise: Promise<fontFinder.FontList> | undefined = undefined;\n\n/**\n * Loads the font ligature wrapper for the specified font family if it could be\n * resolved, throwing if it is unable to find a suitable match.\n * @param fontFamily The CSS font family definition to resolve\n * @param cacheSize The size of the ligature cache to maintain if the font is resolved\n */\nexport default async function load(fontFamily: string, cacheSize: number): Promise<fontLigatures.Font | undefined> {\n  if (!fontsPromise) {\n    fontsPromise = fontFinder.list();\n  }\n\n  const fonts = await fontsPromise;\n  for (const family of parse(fontFamily)) {\n    // If we reach one of the generic font families, the font resolution\n    // will end for the browser and we can't determine the specific font\n    // used. Throw.\n    if (genericFontFamilies.includes(family)) {\n      return undefined;\n    }\n\n    if (fonts.hasOwnProperty(family) && fonts[family].length > 0) {\n      return await fontLigatures.loadFile(fonts[family][0].path, { cacheSize });\n    }\n  }\n\n  // If none of the fonts could resolve, throw an error\n  return undefined;\n}\n\n// https://drafts.csswg.org/css-fonts-4/#generic-font-families\nconst genericFontFamilies = [\n  'serif',\n  'sans-serif',\n  'cursive',\n  'fantasy',\n  'monospace',\n  'system-ui',\n  'emoji',\n  'math',\n  'fangsong'\n];\n","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\ninterface IParseContext {\n  input: string;\n  offset: number;\n}\n\n/**\n * Parses a CSS font family value, returning the component font families\n * contained within.\n *\n * @param family The CSS font family input string to parse\n */\nexport default function parse(family: string): string[] {\n  if (typeof family !== 'string') {\n    throw new Error('Font family must be a string');\n  }\n\n  const context: IParseContext = {\n    input: family,\n    offset: 0\n  };\n\n  const families = [];\n  let currentFamily = '';\n\n  // Work through the input character by character until there are none left.\n  // This lexing and parsing in one pass.\n  while (context.offset < context.input.length) {\n    const char = context.input[context.offset++];\n    switch (char) {\n      // String\n      case '\\'':\n      case '\"':\n        currentFamily += parseString(context, char);\n        break;\n      // End of family\n      case ',':\n        families.push(currentFamily);\n        currentFamily = '';\n        break;\n      default:\n        // Identifiers (whitespace between families is swallowed)\n        if (!/\\s/.test(char)) {\n          context.offset--;\n          currentFamily += parseIdentifier(context);\n          families.push(currentFamily);\n          currentFamily = '';\n        }\n    }\n  }\n\n  return families;\n}\n\n/**\n * Parse a CSS string.\n *\n * @param context Parsing input and offset\n * @param quoteChar The quote character for the string (' or \")\n */\nfunction parseString(context: IParseContext, quoteChar: '\\'' | '\"'): string {\n  let str = '';\n  let escaped = false;\n  while (context.offset < context.input.length) {\n    const char = context.input[context.offset++];\n    if (escaped) {\n      if (/[0-9a-fA-F]/.test(char)) {\n        // Unicode escape\n        context.offset--;\n        str += parseUnicode(context);\n      } else if (char !== '\\n') {\n        // Newlines are ignored if escaped. Other characters are used as is.\n        str += char;\n      }\n      escaped = false;\n    } else {\n      switch (char) {\n        // Terminated quote\n        case quoteChar:\n          return str;\n        // Begin escape\n        case '\\\\':\n          escaped = true;\n          break;\n        // Add character to string\n        default:\n          str += char;\n      }\n    }\n  }\n\n  throw new Error('Unterminated string');\n}\n\n/**\n * Parse a CSS custom identifier.\n *\n * @param context Parsing input and offset\n */\nfunction parseIdentifier(context: IParseContext): string {\n  let str = '';\n  let escaped = false;\n  while (context.offset < context.input.length) {\n    const char = context.input[context.offset++];\n    if (escaped) {\n      if (/[0-9a-fA-F]/.test(char)) {\n        // Unicode escape\n        context.offset--;\n        str += parseUnicode(context);\n      } else {\n        // Everything else is used as is\n        str += char;\n      }\n      escaped = false;\n    } else {\n      switch (char) {\n        // Begin escape\n        case '\\\\':\n          escaped = true;\n          break;\n        // Terminate identifier\n        case ',':\n          return str;\n        default:\n          if (/\\s/.test(char)) {\n            // Whitespace is collapsed into a single space within an identifier\n            if (!str.endsWith(' ')) {\n              str += ' ';\n            }\n          } else {\n            // Add other characters directly\n            str += char;\n          }\n      }\n    }\n  }\n\n  return str;\n}\n\n/**\n * Parse a CSS unicode escape.\n *\n * @param context Parsing input and offset\n */\nfunction parseUnicode(context: IParseContext): string {\n  let str = '';\n  while (context.offset < context.input.length) {\n    const char = context.input[context.offset++];\n    if (/\\s/.test(char)) {\n      // The first whitespace character after a unicode escape indicates the end\n      // of the escape and is swallowed.\n      return unicodeToString(str);\n    }\n    if (str.length >= 6 || !/[0-9a-fA-F]/.test(char)) {\n      // If the next character is not a valid hex digit or we have reached the\n      // maximum of 6 digits in the escape, terminate the escape.\n      context.offset--;\n      return unicodeToString(str);\n    }\n\n    // Otherwise, just add it to the escape\n    str += char;\n  }\n\n  return unicodeToString(str);\n}\n\n/**\n * Convert a unicode code point from a hex string to a utf8 string.\n *\n * @param codePoint Unicode code point represented as a hex string\n */\nfunction unicodeToString(codePoint: string): string {\n  return String.fromCodePoint(parseInt(codePoint, 16));\n}\n"],"sourceRoot":""}